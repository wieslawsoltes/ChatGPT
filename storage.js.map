{
  "version": 3,
  "sources": ["../webapp/modules/storage/indexedDb.ts", "../webapp/modules/storage/storageItem.ts", "../webapp/modules/storage/storageProvider.ts"],
  "sourcesContent": ["class InnerDbConnection {\r\n    constructor(private readonly database: IDBDatabase) { }\r\n\r\n    private openStore(store: string, mode: IDBTransactionMode): IDBObjectStore {\r\n        const tx = this.database.transaction(store, mode);\r\n        return tx.objectStore(store);\r\n    }\r\n\r\n    public async put(store: string, obj: any, key?: IDBValidKey): Promise<IDBValidKey> {\r\n        const os = this.openStore(store, \"readwrite\");\r\n\r\n        return await new Promise((resolve, reject) => {\r\n            const response = os.put(obj, key);\r\n            response.onsuccess = () => {\r\n                resolve(response.result);\r\n            };\r\n            response.onerror = () => {\r\n                reject(response.error);\r\n            };\r\n        });\r\n    }\r\n\r\n    public get(store: string, key: IDBValidKey): any {\r\n        const os = this.openStore(store, \"readonly\");\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const response = os.get(key);\r\n            response.onsuccess = () => {\r\n                resolve(response.result);\r\n            };\r\n            response.onerror = () => {\r\n                reject(response.error);\r\n            };\r\n        });\r\n    }\r\n\r\n    public async delete(store: string, key: IDBValidKey): Promise<void> {\r\n        const os = this.openStore(store, \"readwrite\");\r\n\r\n        return await new Promise((resolve, reject) => {\r\n            const response = os.delete(key);\r\n            response.onsuccess = () => {\r\n                resolve();\r\n            };\r\n            response.onerror = () => {\r\n                reject(response.error);\r\n            };\r\n        });\r\n    }\r\n\r\n    public close() {\r\n        this.database.close();\r\n    }\r\n}\r\n\r\nclass IndexedDbWrapper {\r\n    constructor(private readonly databaseName: string, private readonly objectStores: [string]) {\r\n    }\r\n\r\n    public async connect(): Promise<InnerDbConnection> {\r\n        const conn = window.indexedDB.open(this.databaseName, 1);\r\n\r\n        conn.onupgradeneeded = event => {\r\n            const db = (event.target as IDBRequest<IDBDatabase>).result;\r\n            this.objectStores.forEach(store => {\r\n                db.createObjectStore(store);\r\n            });\r\n        };\r\n\r\n        return await new Promise((resolve, reject) => {\r\n            conn.onsuccess = event => {\r\n                resolve(new InnerDbConnection((event.target as IDBRequest<IDBDatabase>).result));\r\n            };\r\n            conn.onerror = event => {\r\n                reject((event.target as IDBRequest<IDBDatabase>).error);\r\n            };\r\n        });\r\n    }\r\n}\r\n\r\nexport const fileBookmarksStore: string = \"fileBookmarks\";\r\nexport const avaloniaDb = new IndexedDbWrapper(\"AvaloniaDb\", [\r\n    fileBookmarksStore\r\n]);\r\n", "import { avaloniaDb, fileBookmarksStore } from \"./indexedDb\";\r\n\r\nexport class StorageItem {\r\n    constructor(\r\n        public handle?: FileSystemHandle,\r\n        private readonly bookmarkId?: string,\r\n        public wellKnownType?: WellKnownDirectory\r\n    ) {\r\n    }\r\n\r\n    public get name(): string {\r\n        if (this.handle) {\r\n            return this.handle.name;\r\n        }\r\n        return this.wellKnownType ?? \"\";\r\n    }\r\n\r\n    public get kind(): \"file\" | \"directory\" {\r\n        if (this.handle) {\r\n            return this.handle.kind;\r\n        }\r\n        return \"directory\";\r\n    }\r\n\r\n    public static createWellKnownDirectory(type: WellKnownDirectory) {\r\n        return new StorageItem(undefined, undefined, type);\r\n    }\r\n\r\n    public static async openRead(item: StorageItem): Promise<Blob> {\r\n        if (!(item.handle instanceof FileSystemFileHandle)) {\r\n            throw new Error(\"StorageItem is not a file\");\r\n        }\r\n\r\n        await item.verityPermissions(\"read\");\r\n\r\n        const file = await item.handle.getFile();\r\n        return file;\r\n    }\r\n\r\n    public static async openWrite(item: StorageItem): Promise<FileSystemWritableFileStream> {\r\n        if (!(item.handle instanceof FileSystemFileHandle)) {\r\n            throw new Error(\"StorageItem is not a file\");\r\n        }\r\n\r\n        await item.verityPermissions(\"readwrite\");\r\n\r\n        return await item.handle.createWritable({ keepExistingData: true });\r\n    }\r\n\r\n    public static async getProperties(item: StorageItem): Promise<{ Size: number; LastModified: number; Type: string } | null> {\r\n        const file = item.handle instanceof FileSystemFileHandle &&\r\n            await item.handle.getFile();\r\n\r\n        if (!file) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            Size: file.size,\r\n            LastModified: file.lastModified,\r\n            Type: file.type\r\n        };\r\n    }\r\n\r\n    public static async getItems(item: StorageItem): Promise<StorageItems> {\r\n        if (item.kind !== \"directory\" || !item.handle) {\r\n            return new StorageItems([]);\r\n        }\r\n\r\n        const items: StorageItem[] = [];\r\n        for await (const [, value] of (item.handle as any).entries()) {\r\n            items.push(new StorageItem(value));\r\n        }\r\n        return new StorageItems(items);\r\n    }\r\n\r\n    private async verityPermissions(mode: FileSystemPermissionMode): Promise<void | never> {\r\n        if (!this.handle) {\r\n            return;\r\n        }\r\n\r\n        if (await this.handle.queryPermission({ mode }) === \"granted\") {\r\n            return;\r\n        }\r\n\r\n        if (await this.handle.requestPermission({ mode }) === \"denied\") {\r\n            throw new Error(\"Permissions denied\");\r\n        }\r\n    }\r\n\r\n    public static async saveBookmark(item: StorageItem): Promise<string | null> {\r\n        // If file was previously bookmarked, just return old one.\r\n        if (item.bookmarkId) {\r\n            return item.bookmarkId;\r\n        }\r\n        if (!item.handle) {\r\n            return null;\r\n        }\r\n\r\n        const connection = await avaloniaDb.connect();\r\n        try {\r\n            const key = await connection.put(fileBookmarksStore, item.handle, item.generateBookmarkId());\r\n            return key as string;\r\n        } finally {\r\n            connection.close();\r\n        }\r\n    }\r\n\r\n    public static async deleteBookmark(item: StorageItem): Promise<void> {\r\n        if (!item.bookmarkId) {\r\n            return;\r\n        }\r\n\r\n        const connection = await avaloniaDb.connect();\r\n        try {\r\n            await connection.delete(fileBookmarksStore, item.bookmarkId);\r\n        } finally {\r\n            connection.close();\r\n        }\r\n    }\r\n\r\n    private generateBookmarkId(): string {\r\n        return Date.now().toString(36) + Math.random().toString(36).substring(2);\r\n    }\r\n}\r\n\r\nexport class StorageItems {\r\n    constructor(private readonly items: StorageItem[]) { }\r\n\r\n    public static itemsArray(instance: StorageItems): StorageItem[] {\r\n        return instance.items;\r\n    }\r\n}\r\n", "import { avaloniaDb, fileBookmarksStore } from \"./indexedDb\";\r\nimport { StorageItem, StorageItems } from \"./storageItem\";\r\n\r\ndeclare global {\r\n    type WellKnownDirectory = \"desktop\" | \"documents\" | \"downloads\" | \"music\" | \"pictures\" | \"videos\";\r\n    type StartInDirectory = WellKnownDirectory | FileSystemHandle;\r\n    interface OpenFilePickerOptions {\r\n        startIn?: StartInDirectory;\r\n    }\r\n    interface SaveFilePickerOptions {\r\n        startIn?: StartInDirectory;\r\n    }\r\n}\r\n\r\nexport class StorageProvider {\r\n    public static async selectFolderDialog(\r\n        startIn: StorageItem | null): Promise<StorageItem> {\r\n        // 'Picker' API doesn't accept \"null\" as a parameter, so it should be set to undefined.\r\n        const options: DirectoryPickerOptions = {\r\n            startIn: (startIn?.wellKnownType ?? startIn?.handle ?? undefined)\r\n        };\r\n\r\n        const handle = await window.showDirectoryPicker(options);\r\n        return new StorageItem(handle);\r\n    }\r\n\r\n    public static async openFileDialog(\r\n        startIn: StorageItem | null, multiple: boolean,\r\n        types: FilePickerAcceptType[] | null, excludeAcceptAllOption: boolean): Promise<StorageItems> {\r\n        const options: OpenFilePickerOptions = {\r\n            startIn: (startIn?.wellKnownType ?? startIn?.handle ?? undefined),\r\n            multiple,\r\n            excludeAcceptAllOption,\r\n            types: (types ?? undefined)\r\n        };\r\n\r\n        const handles = await window.showOpenFilePicker(options);\r\n        return new StorageItems(handles.map((handle: FileSystemHandle) => new StorageItem(handle)));\r\n    }\r\n\r\n    public static async saveFileDialog(\r\n        startIn: StorageItem | null, suggestedName: string | null,\r\n        types: FilePickerAcceptType[] | null, excludeAcceptAllOption: boolean): Promise<StorageItem> {\r\n        const options: SaveFilePickerOptions = {\r\n            startIn: (startIn?.wellKnownType ?? startIn?.handle ?? undefined),\r\n            suggestedName: (suggestedName ?? undefined),\r\n            excludeAcceptAllOption,\r\n            types: (types ?? undefined)\r\n        };\r\n\r\n        const handle = await window.showSaveFilePicker(options);\r\n        return new StorageItem(handle);\r\n    }\r\n\r\n    public static async openBookmark(key: string): Promise<StorageItem | null> {\r\n        const connection = await avaloniaDb.connect();\r\n        try {\r\n            const handle = await connection.get(fileBookmarksStore, key);\r\n            return handle && new StorageItem(handle, key);\r\n        } finally {\r\n            connection.close();\r\n        }\r\n    }\r\n\r\n    public static createAcceptType(description: string, mimeTypes: string[]): FilePickerAcceptType {\r\n        const accept: Record<string, string[]> = {};\r\n        mimeTypes.forEach(a => { accept[a] = []; });\r\n        return { description, accept };\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["InnerDbConnection", "database", "store", "mode", "obj", "key", "__async", "os", "resolve", "reject", "response", "IndexedDbWrapper", "databaseName", "objectStores", "conn", "event", "db", "fileBookmarksStore", "avaloniaDb", "StorageItem", "handle", "bookmarkId", "wellKnownType", "_a", "type", "item", "__async", "file", "StorageItems", "items", "iter", "__forAwait", "more", "temp", "error", "value", "mode", "connection", "avaloniaDb", "fileBookmarksStore", "instance", "StorageProvider", "startIn", "__async", "_a", "_b", "options", "handle", "StorageItem", "multiple", "types", "excludeAcceptAllOption", "handles", "StorageItems", "suggestedName", "key", "connection", "avaloniaDb", "fileBookmarksStore", "description", "mimeTypes", "accept", "a"]
}
